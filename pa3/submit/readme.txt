/* this file is not hard wrapped */

For this program, there were two major components: the gram.jison file that contains all the grammar rules, and the main.js file that contains the overwritten lexer file and print statements.  The gram.jison file is split by a list of lexer tokens, a list of precedences, the start statement, and the grammar rules based on the Cool Reference Manual. The file method body contains the program and the eof.  The program itself is a recursive method that either terminates on the only class of the program, or iterates through the list of classes through recursive calls.  The class grammar rule includes the class that can inherit a superclass, or a class that just has a body of features.  The features themselves are called recursively similarly to the classes. Formals are recursively called for the features. The expressions themselves are written exactly as they are written in the Cool Manual, with tokens replacing some of the symbols. There are recursions for all the Kleene Star operations.

As for the main.js, the first thing that the program does is store the tokens and their respective line numbers of the lex file in an array. The hacked lexer is defined to be the aforementioned gram.js with the first var statement. The errors are split by carriage return and new line so lines is split by carriage return followed by new line or just new line. The print statements are fairly straightforward. The identifiers are always written with the line number first and value in the next line. This is an often called upon method so it was separated to ease readability. The printAST method starts by printing out the number of classes, then printing out each class. The classes had to include whether it was inherited or not so the if statement is there and the main.js file includes a value for superclass. In each class, there was also a foreach function to print out the features. The -ast file that the cool parser creates was used as reference for the order of printing.  The other separated function was printExp. Expressions had to be called recursively so this was a necessary decision for both readability and functionality. A huge switch case statement was used because if and == statements aren't too elegant.
